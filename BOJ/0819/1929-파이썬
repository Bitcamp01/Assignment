def search_primes(M, N):
    temp = [True] * (N + 1)
    temp[0] = temp[1] = False

    for i in range(2, int(N**0.5) + 1):
        if temp[i]:
            for j in range(i * i, N + 1, i):
                temp[j] = False

    for i in range(M, N + 1):
        if temp[i]:
            print(i)


M, N = map(int, input().split())
search_primes(M, N)


==================================================================================================================================================

이것은 설명이오~

def search_primes(M, N):
    # 처음에, 크기가 N+1인 리스트를 만들되, 모든 값을 True로 설정하였소.
    # 이는 각 숫자가 소수인지 여부를 나타내는 리스트요.
    # 리스트의 0번째와 1번째 인덱스는 소수가 아니므로 False로 설정하였소.
    # True 값은 일단 모든 숫자가 소수일 가능성이 있다고 가정하는 것을 의미하오.
    # 이후, 에라토스테네스의 체 알고리즘을 통해 True 값을 False로 바꿔가며 소수 여부를 판별할 것이오.
    temp = [True] * (N + 1)
    temp[0] = temp[1] = False

    # 이제 2부터 시작하여, N의 제곱근까지 반복문을 돌릴 것이오.
    # 이는 에라토스테네스의 체 알고리즘을 사용하여 소수를 찾기 위함이오.
    # 제곱근까지만 반복문을 실행하는 이유는, 모든 합성수(소수가 아닌 수)는 그 제곱근 이하의 소인수를 가지기 때문이오.
    for i in range(2, int(N**0.5) + 1):
        # 만약 현재 숫자가 소수라면(=True 값이 남아 있다면),
        # 그 숫자의 배수들을 False로 만들어 주겠소.
        if temp[i]:
            # 현재 숫자의 제곱부터 N까지 그 배수들을 순회하겠소.
            # 이들은 더 이상 소수가 아니므로 False로 설정할 것이오.
            for j in range(i * i, N + 1, i):
                temp[j] = False

    # 이제 M부터 N까지의 범위를 순회하면섴,
    # 소수로 남아 있는 숫자들을 출력할 것이오.
    for i in range(M, N + 1):
        # 리스트에서 True로 남아 있는 값들은 소수이므로 출력하겠소.
        if temp[i]:
            print(i)


# 요기서 사용자로부터 두 개의 정수 M과 N을 입력받아, M과 N 사이의 소수를 찾겠소.
M, N = map(int, input().split())
search_primes(M, N)
#이상이오
